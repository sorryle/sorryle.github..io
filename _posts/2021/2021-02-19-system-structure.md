---
layout: post
title: 系统结构第四章-TLB
category: 自考计算机科学与技术
tags: [系统结构]
excerpt: 系统结构第四章-TLB
typora-root-url: ..
---







### **TLB**

> TLB也称为快表，是CPU内部存储页表的地方，通过加载进一部分页表，使得CPU读取数据更快，若是访问的地址命中，就无需访问两次主存，直接从CPU出来就是拿着物理地址访问数据

```mermaid
graph TB 
	a[CPU]-->|1拿着a页表a页号|b{TLB};
	b-->|2|d[TLB有a页表a页号];
	b-->|2|e[TLB没有a页表a页号];
	e-->|拿着a页表a页号|c;
	d-->|3|g[返回实际物理地址];
	c-->|3|g[返回实际物理地址];
	g-->|4|a;
	a-->|5|f[使用物理地址+页偏移值发访问];
	f-->c[存储器];
```

**散列TLB**是使用哈希的方式进行过滤，让查询结果只需要比对几个值就行了，无需对比页表的所有值



### **段式管理**

> 一个程序就有一个段表，段表里面有N个段，每个段大小不一，每个段都可用存储程序里的任意对象。
>
> 如：A程序里面有个方法占了一段大小为3KB,有个变量占了一段为100B。

**段式的访问过程**

```mermaid
sequenceDiagram
	CPU->>基址寄存器:拿着进程号
	基址寄存器-->>CPU: 返回段表所在地址
	CPU->>存储器:搜索段表、段号
	存储器->>段表: 搜段号
	段表-->>CPU: 返回段号所在物理地址
	CPU->>存储器: 根据物理地址+段内偏移值
	存储器-->>CPU: 返回数据
```



### 段页式管理

> 段式管理的空间大小不一，显得很不规范，这时候用段页管理来解决。
>
> 段页式是把程序分成多个段，然后每个段都分页的概念。

**段页式的访问过程**

```mermaid
sequenceDiagram
	CPU->>基址寄存器:拿着进程号
	基址寄存器-->>CPU: 返回段表所在地址
	CPU->>存储器:搜索段表、短号
	存储器->>段表: 搜段号
	段表->>页表: 搜索页号
	页表-->>CPU: 返回物理所在地址
	CPU->>存储器: 根据物理所在地址+页内偏移值
	存储器-->>CPU: 返回数据
```



### 虚拟存储器的工作流程

```mermaid
graph LR    
	a[CPU]-->|1虚拟地址|b{搜索数据}
	b-->|2|c[数据在内存中]
	b-->|2|d[数据在不内存中]
	d-->f{内部地址转外部地址}
	f-->|3|1[数据在辅存中]
	1-->|从辅存加载进内存|e[内存]
	e-->|返回数据|a
	f-->|3|11[数据不在辅存中]
	11-->|数据不存在|a
	c-->e
```

